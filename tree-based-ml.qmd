---
title: "Tree-based Regression"
format: 
  html:
    code-fold: show
    toc: true
    toc-depth: 3
    self-contained: true
editor: visual
---

```{r}
#| include: false

library(tidyverse)
library(data.table)
library(rpart)
library(rattle)
library(wooldridge)
library(reticulate)
use_python("/usr/local/bin/python3")
```

```{r}
#| eval: false

library(tidyverse)
library(data.table)
library(rpart)
library(rattle)
library(wooldridge)
library(reticulate)
use_python("/usr/local/bin/python3")
```

## Regression tree {#sec-rt}

### What is it?

Here is an example of regression tree to explain logged salary (`lsalary`) using the `mlb1` data from the `wooldridge` package. 

```{r}
#| code-fold: true 
#=== get mlb1 data (from wooldridge) ===#
data(mlb1)

#=== build a simple tree ===#
simple_tree <-
  rpart(
    lsalary ~ hits + runsyr, 
    data = mlb1, 
    control = rpart.control(minsplit = 200)
  )

fancyRpartPlot(simple_tree)
```

Here is how you read the figure. At the first node, all the observations belong to it ($n=353$) and the estimate of `lsalary` is 13. Now, the whole datasets are split into two based on the criteria of whether `hits` is less than `262` or not. If yes, then such observations will be grouped into the node with "2" on top (the leftmost node), and the estimated `lsalary` for all the observations in that group ($n = 132$) is 12. If no, then such observations will be grouped into the node with "3" on top, and the estimated `lsalary` for all the observations in that group ($n = 221$) is 14. This node is further split into two groups based on whether `runsyr` is less than 44 or not. For those observations with `runsyr` $< 44$ (second node a the bottom), estimated `lsalary` is 14. For those with `runsyr` $>= 44$ (rightmost node at the bottom), estimated `lsalary` is 15. The nodes that do not have any further bifurcations below are called terminal nodes or leafs. 

As illustrated in the figure above, a regression tree splits the data into groups based on the value of explanatory variables, and all the observations in the same group will be assigned the same estimate (the sample average of the dependent variable of the group). 

Another way of illustrating this grouping is shown below:

```{r viz-tree}
#| code-fold: true 

ggplot(mlb1) +
  geom_point(aes(y = hits, x = runsyr, color = lsalary)) +
  scale_color_viridis_c() +
  geom_hline(yintercept = 262) +
  geom_line(
    data = data.table(x = 44, y = seq(262, max(mlb1$hits), length = 100)), 
    aes(y = y, x = x)
  ) +
  annotate(
    "text", 
    x = 44, y = 111, 
    label = "Region 2", 
    color = "red"
  ) +
  annotate(
    "text", 
    x = 22, y = 1500, 
    label = "Region 6", 
    color = "red"
  ) +
  annotate(
    "text", 
    x = 75, y = 1500, 
    label = "Region 7", 
    color = "red"
  )
```

The mechanism called recursive binary splitting is used to split the predictor space like the example above. Suppose you have K explanatory variables ($X_1, \dots, X_k$). Further, let $c$ denote the cutpoint that splits the sample into two regions: \{$X|X_k < c$\} and \{$X|X_k \geq c$\}.

::: {.column-margin}
\{$X|X_k < c$\} means observations that satisfy the condition stated right to the vertical bar (|). Here, it means all the observations for which its $X_k$ value is less than $c$.
:::

+ Step 1: For each of the explanatory variables ($X_1$ through $X_K$), find the cutpoint that leads to the lowest sum of the squared residuals. 
+ Step 2: Among all the splits (as many as the number of explanatory variables), pick the variable-cutpoint combination that leads to the lowest sum of the squared residuals.

The data is then split according to the chosen criteria and then the same process is repeated for each of the branches, ad infinitum until the user-specified stopping criteria is met. 

Let's try to write (an inefficient version) this process for the first split from the beginning node using the `mlb1` data as an illustration based on a simple grid search to find the optimal cutpoints (Step 1). 

```{r set-up-data}
#=== get data ===#
library(wooldridge)
data(mlb1)

mlb1_dt <- 
  mlb1 %>% 
  data.table() %>% # turn into data.table 
  .[, salary := NULL] %>% # remove salary (use lsalary instead)
  na.omit() # remove observations with NA in any of the variables
```

Let's work on splitting based on `hruns`. First, we define a sequence of values of cutpoints for `hruns`.

```{r gen-value-seq}
value_seq <- 
  quantile(
    mlb1_dt$hruns, 
    prob = seq(0.001, 0.999, length = 100)
  ) %>% 
  unique()
```

For each value in `value_seq`, we find the RSS. For example, for the 50th value in `value_seq`,

```{r}
copy(mlb1_dt) %>% 
  #=== find the mean of lsalary by whether hruns is less than the cutpoint or not ===#
  .[, y_hat := mean(lsalary), by = (hruns < value_seq[50])] %>% 
  #=== get squared residuals ===#
  .[, (lsalary - y_hat)^2] %>% 
  #=== get RSS ===#
  sum()
```

How about 70th value in `value_seq`?

```{r}
copy(mlb1_dt) %>% 
  #=== find the mean of lsalary by whether hruns is less than the cutpoint or not ===#
  .[, y_hat := mean(lsalary), by = (hruns < value_seq[70])] %>% 
  #=== get squared residuals ===#
  .[, (lsalary - y_hat)^2] %>% 
  #=== get RSS ===#
  sum()
```

This means `value_seq[70]` (`r value_seq[70]`) is a better cutpoint than `value_seq[50]` (`r value_seq[50]`).

Okay, let's consider all the candidate values, not just 50th and 70th, and then pick the best.

```{r}
get_rss <- function(i, var_name, value_seq, data)
{
  rss <-
    copy(data) %>% 
    setnames(var_name, "var") %>% 
    .[, y_hat := mean(lsalary), by = (var < value_seq[i])] %>% 
    .[, (lsalary - y_hat)^2] %>% 
    sum()

  return_data <-
    data.table(
      rss = rss,
      var_name = var_name,
      var_value = value_seq[i]
    )

  return(return_data)
}
```

Here are RSS values at every value in `value_seq`.

```{r}
rss_value <-
  lapply(
    seq_len(length(value_seq)),
    function(x) get_rss(x, "hruns", value_seq, mlb1_dt) 
  ) %>% 
  rbindlist()

head(rss_value)
tail(rss_value)
```

Finding the cutpoint value that minimizes RSS,

```{r}
rss_value[which.min(rss), ]
```

Okay, so, the best cutpoint for `hruns` is `r round(rss_value[which.min(rss), var_value], digits = 3)`

Suppose we are considering only five explanatory variables in building a regression tree: `hruns`, `years`, `rbisyr`, `allstar`, `runsyr`, `hits`, and `bavg`. We do the same operation we did for `hruns` for all the variables. 

```{r}
get_rss_by_var <- function(var_name, data)
{
  temp_data <- copy(data) 

  #=== define a sequence of values of hruns ===#
  value_seq <- 
    quantile(
      temp_data[, ..var_name] %>% unlist(), 
      prob = seq(0.001, 0.999, length = 100)
    ) %>% 
    unique()

  #=== get RSS ===#
  rss_value <-
    lapply(
      seq_len(length(value_seq)),
      function(x) get_rss(x, var_name, value_seq, temp_data) 
    ) %>% 
    rbindlist() %>% 
    .[which.min(rss),]

  return(rss_value)
}
```

Looping over the set of variables,

```{r}
(
min_rss_by_var <-
  lapply(
    c("hruns", "years", "rbisyr", "allstar", "runsyr", "hits", "bavg"),
    function(x) get_rss_by_var(x, mlb1_dt)
  ) %>% 
  rbindlist()
)
```

So, the variable-cutpoint combination that minimizes RSS is `r min_rss_by_var[which.min(rss), var_name]` - `r min_rss_by_var[which.min(rss), round(var_value, digits = 2)]`. We now have the first split. This tree is developed further by splitting nodes like this. 


### Training a regression tree in R

You can fit a regression tree using `rpart()` from the `rpart` package. Its syntax is similar to that of `lm()` for a quick fitting.

```{r}
#| eval: false 

rpart(
  formula,
  data
)

```

Using `mlb1`, let's fit a regression tree where `lsalary` is the dependent variable and `hruns`, `years`, `rbisyr`, `allstar`, `runsyr`, `hits`, and `bavg` are the explanatory variables.

```{r}
 
#=== fit a tree ===#
fitted_tree <-
  rpart(
    lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, 
    data = mlb1_dt
  )
```

Here is the visualization of the fitted tree using `fancyRpartPlot()` from the `rattle` package.

```{r}
fancyRpartPlot(fitted_tree)
```

Now, you may wonder why `rpart()` is not building a tree that has as many leaves as the number of observations so that we have a perfect prediction for the train data (`mlb1`). If we are simply implementing recursive binary splitting, then it should not have stopped where it stopped. This is because `rpart()` sets parameter values that control the development of a tree by default. Those default parameters can be seen below:

```{r}
rpart.control()
```

For example, `minsplit` is the minimum number of observations that must exist in a node in order for a split to be attempted. `cp` refers to the complexity parameter. For a given value of `cp`, a tree is build to minimize the following:

$$
\sum_{t=1}^T\sum_{x_i\in R_t} (y_i - \hat{y}_{R_t})^2 + cp\cdot T
$$

where $R_t$ is the $t$th region and $\hat{y_{R_t}}$ is the estimate of $y$ for all the observations that reside in $R_t$. So, the first term is RSS. The objective function has a penalization term (the second term) just like shrinkage methods we saw in @sec-shrinkage. A higher value of `cp` leads to a less complex tree with less leaves.

If you want to build a much deeper tree that has many leaves, then you can do so using the `control` option like below.

```{r}
full_tree <-
  rpart(
    lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, # formula
    data = mlb1_dt, # data
    control = # control of the hyper parameters
      rpart.control(
        minsplit = 2, 
        cp = 0 # complexity parameter
      )
  )
```

Let's see how amazing this tree is by comparing the observed and fitted `lsalary` values.

```{r}
#=== get fitted values ===#
mlb1_dt[, y_hat := predict(full_tree, newdata = mlb1_dt)]

#=== visualize the fit ===#
ggplot(data = mlb1_dt) +
  geom_point(aes(y = lsalary, x = y_hat)) +
  geom_abline(slope = 1, color = "red")
```

Yes, perfect prediction accuracy! At least for the train data anyway. But, we all know we want nothing to do with this kind of model. It is clearly over-fitting the train data.  

In order to find a reasonable model, we can use KCV over `cp`. Fortunately, when we run `rpart()`, it automatically builds multiple trees at different values of `cp` that controls the number of leaves and conduct KCV. You can visualize this using `plotcp()`.

```{r}
plotcp(fitted_tree)
```

MSE and `cp` are presented on the y- and x-axis, respectively. According to the KCV results, `cp` $= 0.018$ provides the tree with the smallest number of leaves (the most simple) where the MSE value is within one standard deviation from the lowest MSE. You can access the tree built under `cp` $= 0.018$ like below.

```{r}
#=== get the best tree ===#
best_tree <- prune(full_tree, cp = 0.018)

#=== visualize it ===#
fancyRpartPlot(best_tree)
```

Even though how a regression tree is build in R. In practice, you never use a regression tree itself as the final model for your research as its performance is rather poor and tend to over-fit compared to other competitive methods. But, understanding how building a regression tree is important to understand its derivatives like random forest, boosted regression forest.

## Random Forest (RF) {#sec-rf}

Regression tree approach is often not robust and suffers from high variance. Here, we look at the process called <span style="color:blue"> bagging </span> and how it can be used to train RF model, which is much more robust than a regression tree. 

### Bagging (Bootstrap aggregation)

Consider two random variables $x_1$ and $x_2$ from the identical distribution, where $E[x_i] = \alpha$ and $Var(x_i) = \sigma^2$. You are interested in estimating $E[x_i]$. We all know that the following relationship holds in general:

$$
\begin{aligned}
Var(\frac{x_1 + x_2}{2}) & = \frac{Var(x_1)}{4} + \frac{Var(x_2)}{4} + \frac{Cov(x_1, x_2)}{2} \\
& = \frac{\sigma^2}{2} + \frac{Cov(x_1, x_2)}{2}
\end{aligned}
$$

So, instead of using a single draw from $x_1$ and using it as an estimate for $E[x_i]$, it is better to use the values from both $x_1$ and $x_2$ and average them to obtain an estimate for $E[x_i]$ as long as $x_1$ and $x_2$ are not perfectly <span style="color:blue"> positively </span> correlated (in this case $Cov(x_1, x_2) = Var(x_1) = Var(x_1) = \sigma^2$). The benefit of averaging is greater when the value of $Cov(x_1, x_2)$ is smaller. 

Let's do a little experiment to see this. We consider three cases:

```{r}
#=== set the number of observations to 1000 ===#
N <- 1000
```

```{r}
#=== first case (no correlation) ===#
x_1 <- rnorm(N)
x_2 <- rnorm(N)

cor(x_1, x_2)

#=== second case (positively correlated) ===#
x_1 <- rnorm(N)
x_2 <- 0.5 * x_1 + sqrt(1-(0.5)^2) * rnorm(N)

cor(x_1, x_2)

#=== third case (negatively correlated) ===#
x_1 <- rnorm(N)
x_2 <- - 0.8 * x_1 - sqrt(1-(0.8)^2) * rnorm(N)

cor(x_1, x_2)
```

```{r}
get_alpha <- function(i)
{
  #=== base case ===#
  alpha_hat_0 <- rnorm(1)

  #=== first case (no correlation) ===#
  x_1 <- rnorm(1)
  x_2 <- rnorm(1)

  alpha_hat_1 <- (x_1 + x_2) / 2

  #=== second case (positively correlated) ===#
  x_1 <- rnorm(1)
  x_2 <- 0.5 * x_1 + sqrt(1-(0.5)^2) * rnorm(1)

  alpha_hat_2 <- (x_1 + x_2) / 2

  #=== third case (negatively correlated) ===#
  x_1 <- rnorm(1)
  x_2 <- - 0.8 * x_1 - sqrt(1-(0.8)^2) * rnorm(1)

  alpha_hat_3 <- (x_1 + x_2) / 2

  return_data <-
    data.table(
      alpha_hat_0 = alpha_hat_0,
      alpha_hat_1 = alpha_hat_1,
      alpha_hat_2 = alpha_hat_2,
      alpha_hat_3 = alpha_hat_3
    )

  return(return_data)

} 
```

```{r}
set.seed(234934)

sim_results <-
  lapply(
    1:1000,
    get_alpha
  ) %>% 
  rbindlist() %>% 
  melt()

```

As you can see below, they are all pretty much unbiased. However, all the cases that averaged two values (cases 1, 2, and 3) outperformed the base case that relied on a single value each iteration. You can see that when the random variables are negatively correlated, the power of averaging is greater compared to when they are independent or positively correlated. The independent case (case 1) is better than the positive correlation case (case 2). 

```{r}
#=== expected value ===#
sim_results[, mean(value), by = variable]

#=== standard error ===#
sim_results[, sd(value), by = variable]
```

Bagging takes advantage of the power of averaging. Specifically, bagging takes the following steps:

1. Generate many bootstrapped datasets (say $B$ datasets)
2. Train a model on each of the bootstrapped datasets ($\hat{f}^1, \dots, \hat{f}^B$)
3. Average the estimates from all the trained models to come up with an estimate 
$$
\hat{f}(X) = \frac{\hat{f}^1(X) + \dots + \hat{f}^B(X)}{B}
$$

Let's implement this for $B = 10$ using `mlb1_dt`. First, define a function (named `train_a_tree()`) that bootstrap data, fit a regression tree, and then return the fitted values. 

```{r}

train_a_tree <- function(i, data)
{
  #=== number of observations ===#
  N <- nrow(data)

  #=== bootstrapped data ===#
  boot_data <- data[sample(1:N, N, replace = TRUE), ]

  #=== train a regression tree ===#
  rpart <-
    rpart(
      lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, 
      data = boot_data
    )

  #=== predict ===#
  return_data <-
    copy(data) %>% 
    .[, y_hat := predict(rpart, newdata = data)] %>% 
    .[, .(id, y_hat)]

  return(return_data)
}
```

We now repeat `train_a_tree()` 10 times.

```{r}
#=== create observation id for later group-by averaging ===#
mlb1_dt[, id := 1:.N]

(
y_estimates <-
  lapply(
    1:10,
    function(x) train_a_tree(x, mlb1_dt) 
  ) %>% 
  rbindlist()
)

```

By averaging $y$ estimates by `id`, we can get bagging estimates.

```{r}
y_estimates[, mean(y_hat), by = id]
```

Now, let's take a look at the individual estimates of $y$ for the first observation.

```{r}
y_estimates[id == 1, ]
```

Hmm, the estimates look very similar. Actually, that is the case for all the observations. This is because the trained trees are very similar for many reasons, and the trees are highly "positively" correlated with each other. From our very simple experiment above, we know that the power of bagging is not very high when that is the case. While RF does use bagging, popular R and python packages does it in a much better way than I demonstrated here. We see this next.


### Random Forest (RF)

Unlike a naive bagging approach I demonstrated above, RF does it in a clever way to *decorrelate* trees. Specifically, for any leave of any tree, they consider only a randomly select subset of the explanatory variables when deciding how to split a leave. A typical choice of the number of variables considered at each split is $\sqrt{K}$, where $K$ is the number of the explanatory variables specified by the user. In the naive example above, all $K$ variables are considered for all the split decisions of all the trees. Some variables are more influential than others and they get to be picked as the splitting variable at similar places, which can result in highly correlated trees. Instead, RF gives other variables a chance, which helps decorrelate the trees.


We can use `ranger()` from the `ranger` package to train an RF model. 

::: {.column-margin}
Another compelling R package for RF is the `randomForest` package.
:::

The `ranger()` function has many options you can specify that determine how trees are built. Here are some of the important ones (see [here](https://cran.r-project.org/web/packages/ranger/ranger.pdf) for the complete description of the hyper-parameters.):

+ `mtry`: the number of variables considered in each split (default is the square root of the total numbers of explanatory variables rounded down.)
+ `num.trees`: the number of tree to be built (default is 500)
+ `min.node.size`: minimum number of observations in each node (default varies based on the the type of analysis)
+ `replace`: where sample with or without replacement when bootstrapping samples (default is `TRUE`)
+ `sample.fraction`: the fraction of the entire observations that are used in each tree (default is 1 if sampling with replacement, 0.632 if sampling without replacement)

Let's try fitting an RF with `ranger()` with the default parameters.

```{r}
#=== load the package ===#
library(ranger)

#=== fit and RF ===#
(
rf_fit <- 
  ranger(
    lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, 
    data = mlb1_dt
  )
)
```


::: {.column-margin}
Since we have many trees, it is no longer possible to have a nice graphical representation of the trained RF model like we did with a regression tree.
:::

In the output, you can see `OOB prediction error (MSE)`. OOB stands for <span style="color:red"> o</span>ut-<span style="color:red">o</span>f-<span style="color:red">b</span>ag. When bootstrapping (whether you do it with replacement or not), some of the train data will not be used to build a tree. 

```{r}
n_obs <- nrow(mlb1_dt)

#=== bootstrapped data ===#
boot_data <- mlb1_dt[sample(1:n_obs, n_obs, replace = TRUE), ]

#=== which rows (observations) from the original datasets are missing? ===#
mlb1_dt[, id %in% unique(boot_data$id)] %>% mean()
```

So, only $65\%$ of the rows from the original data (`mlb1_dt`) in this bootstrapped sample (many duplicates of the original observations). The observations that are NOT included in the bootstrapped sample is called out-of-bag observations. This provides a great opportunity to estimate test MSE while training an RF model! For a given regression tree, you can apply it to the out-of-bag samples to calculate MSE. You can repeat this for all the trees and average the MSEs, effectively conducting cross-validation. When the number of trees is large enough, OOB MSE is almost equivalent to MSE from LOOCV [@james2013introduction]. This means that we can tune hyper-parameters by comparing OOB MSEs of different configurations of them.

You can use a simple grid-search to find the best hyper-parameters. Grid-search is simply a brute-force optimization methods that goes through all the combinations of hyper-parameters and see which combination comes at the top. The computational intensity of grid-search depends on how many hyper-parameters you want to vary and how many values you would like to look at for each of the hyper-parameters. Here, let's tune `mtry`, `min.node.size`, and `sample.fraction`.

```{r}
#=== define set of values you want to look at ===#
mtry_seq <- c(2, 4, 7)
min_node_size_seq <- c(2, 5, 10)
sample_fraction_seq <- c(0.5, 0.75, 1)

#=== create a complete combinations of the three parameters ===#
(
parameters <-
  data.table::CJ(
    mtry = mtry_seq,
    min_node_size = min_node_size_seq,
    sample_fraction = sample_fraction_seq
  )
)
```

In total, we have 27 ($3 \times 3 \times 3$) cases. You can see how quickly the number of cases increases  as you increase the number of parameters to tune and the values of each parameter. We can now loop over the rows of this parameter data (`parameters`) and get OOB MSE for each of them.

```{r}
oob_mse_all <-
  lapply(
    seq_len(nrow(parameters)),
    function(x) {

      #=== Fit the mode ===#
      rf_fit <- 
        ranger(
          lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, 
          data = mlb1_dt,
          num.trees = 1000,
          mtry = parameters[x, mtry],
          min.node.size = parameters[x, min_node_size],
          sample.fraction = parameters[x, sample_fraction]
        )

      #=== return OOB SME ===#
      return(rf_fit$prediction.error)
      
    }
  ) %>% 
  unlist()

#=== assign OOB MSE to the parameters data ===#
parameters[, oob_mse := oob_mse_all]

#=== take a look ===#
parameters
```

So, the best choice among the ones tried is:

```{r}
parameters[which.min(oob_mse), ]
```


## Boosted Regression Forest

### Gradient Boosting

In training RF that uses the idea of bagging, the original data is used to generate many bootstrapped datasets, a regression tree is trained on each of them <span style="color:blue"> independently </span>, and then they are averaged to reach the final model. Boosting is similar to bagging (bootstrap aggregation) in that it trains many statistical models and then combine them to reach the final model. However, instead of building many trees independently, it builds trees <span style="color:blue"> sequentially </span> in a manner that improves prediction step by step.

While there are many variants of boosting methods (see Chapter 10 of @hastie2009elements), we will look at gradient boosting using trees for regression in particular (Algorithm 10.3 in @hastie2009elements presents the generic gradient tree boosting algorithm), where squared error is used as the loss function.  

1. Set $f_0(X_i)  = \frac{\sum_{i=1}^N y_i}{N}$ for all $i = 1, \dots, N$
2. For b = 1 to B,
  i. For $i = 1, \dots, N$, calculate
    $$
    r_{i,b} =  (y_i - f_{b-1}(X_i))
    $$
  ii. Fit a regression tree to $r_{i, b}$, which generates terminal regions $R_{j,b}$, $j = 1, \dots, J$, and denote the predicted value of region $R_{j,b}$ as $\gamma_{j,b}$.
  iii. Set $f_b(X_i) = f_{b-1}(X_i) + \lambda \cdot \sum_{j=1}^J\gamma_{j, b}\cdot I(X_i \in R_{j,b})$
3. Finally, $\hat{f}(X_i) = f_B(X_i)$

Let's try to go through this algorithm a bit to have it sink in for you.

Step 1

Step 1 finds the mean of the dependent variable. This quantity is used as the starting estimate for the dependent variable. 

```{r}
(
f_0 <- mean(mlb1_dt$lsalary)
)
```

Step 2: $b = 1$

Now, we get residuals:

```{r}
mlb1_dt[, resid_1 := lsalary - f_0]
```

The residuals contain information in `lsalary` that was left unexplained. By training a regression tree using the residuals as the dependent variable, we are finding a tree that can explain the unexplained parts of `lsalary` using the explanatory variables. 

```{r}
tree_fit_b1 <- 
  rpart(
    resid_1 ~ ., # . means all variables
    data = mlb1_dt 
  )
```

Here is the fitted value of the residuals ($\sum_{j=1}^J\gamma_{j, b}\cdot I(X_i \in R_{j,b})$)

```{r}
resid_1_hat <- predict(tree_fit_b1, newdata = mlb1_dt)
head(resid_1_hat)
```

Now, we update our prediction according to $f_b(X_i) = f_{b-1}(X_i) + \lambda \cdot \sum_{j=1}^J\gamma_{j, b}\cdot I(X_i \in R_{j,b})$. We set $\lambda$ to be $0.2$ in this illustration.

```{r}
lambda <- 0.2
f_1 <- f_0 + lambda * resid_1_hat
head(f_1)
```

Did we actually improve prediction accuracy? Let's compare `f_0` and `f_1`.

```{r}
sum((mlb1_dt$lsalary - f_0)^2)
sum((mlb1_dt$lsalary - f_1)^2)
```

Great. Let's move on to $b = 2$.

```{r}
#=== get negative of the residuals ===#
mlb1_dt[, resid_2 := lsalary - f_1]

#=== fit a regression tree ===#
tree_fit_b2 <- 
  rpart(
    resid_2 ~ ., # . means all variables
    data = mlb1_dt 
  )

#=== get predicted values ===#
resid_2_hat <- predict(tree_fit_b2, newdata = mlb1_dt)

#=== update ===#
f_2 <- f_1 + lambda * resid_2_hat
```

```{r}
sum((mlb1_dt$lsalary - f_1)^2)
sum((mlb1_dt$lsalary - f_2)^2)
```

We further improved our predictions. We repeat this process until certain user-specified stopping criteria is met. 

As you probably have noticed, there are several key parameters in the process above that controls the performance of gradient boosting forest. $\lambda$ controls the speed of learning. The lower $\lambda$ is, slower the learning speed is. $B$ (the number of trees) determines how many times we want to make small improvements to the original prediction. When you increase the value of $\lambda$, you should decrease the value of $B$. Too high values of $\lambda$ and $B$ can lead to over-fitting. 

You may have been wondering why this algorithm is called `Gradient` boosting. Gradient boosting is a much more general than the one described here particularly for gradient tree boosting for regression. It can be applied to both regression and classification^[Indeed, all the algorithms and models we have talked about can be applied to classification problems with some small changes.]. In general, Step 2.a can be written as follows:

$$
r_{i,b} = - \huge[\normalsize\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\huge]\normalsize_{f = f_{b-1}}
$$

where $L(y_i, f(x_i))$ is the loss function. For regression, the loss function is almost always squared error: $(y_i - f(x_i))^2$. For, $L(y_i, f(x_i)) = (y_i - f(x_i))^2$, the negative of the derivative of the loss function with respect to $f(x_i)$ is 

$$
- \huge[\normalsize\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}\huge]\normalsize_{f = f_{b-1}} = - (- 2 (y_i - f(x_i))) = 2 (y_i - f(x_i)) 
$$

This is why we have $r_{i,b} = (y_i - f_{b-1}(X_i))$ at Step 2.a. And, as you just saw, we are using the gradient of the loss function for model updating, which is why it is called <span style="color:blue"> gradient </span> boosting. Note that it does not really matter whether you have $2$ in front of the residuals or not the fitted residuals is multiplied (scaled) by $\lambda$ to when updating the model. You can always find the same $\lambda$ that would result in the same results as when just non-scaled residuals are used.

Most R and python packages allow you to use a fraction of the train sample that are randomly selected and/or to use a subset of the included variables in building a tree within Step 2. This generate randomness in the algorithm and they are referred to as <span style="color:blue"> stochastic </span>gradient boosting.

### Implementation in R

We can use the `gbm` package to train a gradient boosting regression. Just like `ranger()`, `gbm` takes formula and data like below.

```{r}
library(gbm)

#=== fit a gbm model ===#
gbm_fit <- 
  gbm(
    lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, 
    data = mlb1_dt 
  )
```

Here is the list of some parameters to be aware of:

+ `n.trees`: Number of trees ($B$). Default is $100$.
+ `interaction.depth`: 1 implies an additive model without interactions between included variables^[You can of course create interactions terms yourself in the data, which would allow simple linear 2-way interactions.], 2 implies a model with 2-way interactions. Default is 1.
+ `n.minobsinnode`: Minimum number of observations in the terminal nodes. 
+ `shrinkage`: Learning rate ($\lambda$). Default is 0.1.
+ `bag.fraction`: The fraction of the train data observations that are select randomly in building a tree. Default is 0.5.
+ `cv.folds`: The number of folds in conducting KCV

By specifying `cv.folds`, `gbm()` automatically conducts cross-validation for you. 

```{r}
#=== gbm fit with CV ===#
gbm_fit <- 
  gbm(
    lsalary ~ hruns + years + rbisyr + allstar + runsyr + hits + bavg, # . means all variables
    data = mlb1_dt,
    cv.folds = 5,
  )

#=== see the MSE history ===#  
gbm_fit$cv.error
```

You can visualize the CV results using `gbm.perf()`.

```{r}
gbm.perf(gbm_fit)
```

Note that it will tell you what the optimal number of trees is <span style="color:blue"> given </span> the values of the other hyper-parameters (here default values). If you want to tune other parameters as well, you need to program it yourself. 

## Extreme Gradient Boosting

Extreme gradient boosting (XGB) is a variant of gradient boosting that has been extremely popular due to its superb performance. The basic concept is the same as the gradient boosting algorithm described above, however, it has its own way of building a tree, which is more mindful of avoiding over-fitting trees. 

### Tree updating in XGB (general)

Let $f_{i,b}(x_i)$ be the prediction for the $i$th observation at the $b$-th iteration. Further, let $w_t(x_i)$ is the term that is added to $f_{i,b}(x_i)$ to obtain $f_{i,b+1}(x_i)$. In XGB, $w_t(x_i)$ is such that it minimizes the following objective:

$$
\Psi_t = \sum_{i=1}^N [L(y_i, f_{i,b}(x_i) + w_t(x_i))] + \Omega(w_t)
$$ {#eq-obj}

where $L()$ is the user-specified loss-function that is differentiable and $\Omega(w_t)$ is the regularization term. Instead of @eq-obj, XGB uses the second order Taylor expansion of $L()$ about $w$^[This helps for some of the commonly used loss functions]. 

$$
\tilde{\Psi}_t = \sum_{i=1}^N [L(y_i, f_{i,b}(x_i)) + g_i w_t(x_i) + \frac{1}{2}h_i w_t(x_i)^2] + \Omega(w_t)
$$ {#eq-obj-taylor}

where $g_i = \frac{\partial L(y_i, p_i)}{\partial p_i}$ (first-order derivative) and $h_i = \frac{\partial^2 L(y_i, p_i)}{\partial p_i^2}$ (second-order derivative). Since $L(y_i, f_{i,b}(x_i))$ is just a constant, we can safely remove it from the objective function, which leads to

$$
\tilde{\Psi}_t = \sum_{i=1}^N [g_i w_t(x_i) + \frac{1}{2}h_i w_t(x_i)^2] + \Omega(w_t)
$$ {#eq-obj-taylor-final}

Let $I_j$ denote a set of observations that belong to leaf $j$ ($j = 1, \dots, J$). Then, @eq-obj-taylor-final is written as follows:

$$
\tilde{\Psi}_t = \sum_{j=1}^J\huge[\normalsize (\sum_{i\in I_j}g_i)w_j + \frac{1}{2}(\sum_{i\in I_j}h_i + \lambda)w_j^2 \huge]\normalsize + \gamma J
$$ {#eq-obj-taylor-tree}

::: {.column-margin}
Remember that all the observations in the same leaf shares the same prediction. So, for all $i$s that belong to leaf $j$, the prediction is denoted as $w_j$ in @eq-obj-taylor-tree. That is, $w_t(x_i)$ that belongs to leaf $j$ is $w_j$.
:::

For a given tree structure (denoted as $q(x)$), the leaves can be treated independently in minimizing this objective. 

Taking the derivative of $\tilde{\Psi}_t$ w.r.t $w_j$, 

$$
\begin{aligned}
(\sum_{i\in I_j}g_i) + (\sum_{i\in I_j}h_i + \lambda)w_j = 0 \\
\Rightarrow w_j^* = \frac{-\sum_{i\in I_j}g_i}{\sum_{i\in I_j}h_i + \lambda}
\end{aligned}
$$ {#eq-foc-leaf}

The minimized value of $\tilde{\Psi}_t$ is then (obtained by plugging $w_j^*$ into @eq-obj-taylor-tree),

$$
\begin{aligned}
\tilde{\Psi}_t(q)^* & = \sum_{j=1}^J\huge[\normalsize (\sum_{i\in I_j}g_i)\frac{-\sum_{i\in I_j}g_i}{\sum_{i\in I_j}h_i + \lambda} + \frac{1}{2}(\sum_{i\in I_j}h_i + \lambda)(\frac{-\sum_{i\in I_j}g_i}{\sum_{i\in I_j}h_i + \lambda})^2 \huge]\normalsize + \gamma J \\
& = \sum_{j=1}^J\huge[\normalsize \frac{-(\sum_{i\in I_j}g_i)^2}{\sum_{i\in I_j}h_i + \lambda} + \frac{1}{2}\frac{(\sum_{i\in I_j}g_i)^2}{\sum_{i\in I_j}h_i + \lambda} \huge]\normalsize + \gamma J \\
& = -\frac{1}{2} \sum_{j=1}^J \huge[\normalsize\frac{(\sum_{i\in I_j}g_i)^2}{\sum_{i\in I_j}h_i + \lambda}\huge]\normalsize + \gamma J
\end{aligned} 
$$ {#eq-minimized-obj}

For notatinal convenience, we call $\frac{(\sum_{i\in I_j}g_i)^2}{\sum_{i\in I_j}h_i + \lambda}$ quality score and denote it by $Q_j$ (<span style="color:red"> Q</span>uality score for leaf $j$).

We could find the best tree structure by finding $w_j^*(q)$ according to @eq-obj-taylor-tree and calculate $\tilde{\Psi}_t(q)^*$ according to @eq-minimized-obj for each of all the possible tree structures, and then pick the tree structure q(x) that has the lowest $\tilde{\Psi}_t(q)^*$. 

However, it is impossible to consider all possible tree structures practically. So, a greedy (myopic) approach that starts from a single leaf and iteratively splits leaves is used instead. 

Consider splitting an existing leaf $s$ (where in the tree it may be located) into two leaves $L$ and $R$ when there are $J$ existing leaves. Then, we find $w_j^*$ and calculate $\tilde{\Psi}_t(q)^*$ for each leaf, and the resulting minimized objective is

$$
-\frac{1}{2} \huge[\normalsize Q_L + Q_R + \Gamma \huge]\normalsize + \gamma(J+1)
$$

where $\Gamma$ is the sum of quality scores for all the leaves except $L$ and $R$. 

::: {.column-margin}
$$
\Gamma = \sum_{j\ne \{L, R\}}^J Q_j
$$
:::

The minimized objective before splitting is

$$
-\frac{1}{2} \huge[\normalsize Q_s + \Gamma \huge]\normalsize + \gamma J
$$

So, the <span style="color:blue">reduction </span> in loss after the split is

$$
G(s, L, R) = \frac{1}{2} \huge[\normalsize Q_L + Q_R - Q_s \huge]\normalsize - \gamma
$$

Let's call $G(s, L, R)$ simply a gain (of the split).

::: {.column-margin}
A more positive value of gain ($G(s, L, R)$) means a more successful split.

:::

We can try many different patterns of $I_L$ and $I_R$ (how to split tree $s$), calculate the gain for each of them and pick the split that has the highest gain.

::: {.column-margin}
Different patterns of $I_L$ and $I_R$ arise from different variable-cutpoint combinations 
:::

If the highest gain is negative, then the leaf under consideration for splitting is not split. 

Once the best tree is chosen (the tree that has the highest gain among the ones investigated), then we update our prediction based on $w^*$ of the tree. For observation $i$ that belongs to leaf $j$ of the tree,

$$
\begin{aligned}
f_{i,b} = f_{i,b-1} + \eta \cdot w_j^*
\end{aligned}
$$ {#eq-update}

where $\eta$ is the learning rate.

### Tree updating in XGB (regression)

We now make the general tree updating algorithm specific to regression problems, where the loss function is squared error: $L(y_i, p_i) = \frac{1}{2}(y_i - p_i)^2$, where $p_i$ is the predicted value for $i$. 

<!-- We first set the mean of $y$ as the predicted value for all the observations and denote it by $y_0$.  -->

First, let's find $g_i$ and $h_i$ for $L(y_i, p_i) = \frac{1}{2}(y_i - p_i)^2$.

$$
\begin{aligned} 
g_i = \frac{\partial L(y_i, p_i)}{\partial p_i}  = -(y_i - p_i)\\
h_i = \frac{\partial^2 L(y_i, p_i)}{\partial p_i^2} = 1 \\
\end{aligned}
$$

So, $g_i$ is simply the negative of the residual for $i$. 

Now, suppose your are at iteration $b$ and the predicted value for $i$ is denoted as $f_{i,b}(x_i)$. Further, let $r_{i,b}$ denote the residual ($y_i - f_{i,b}(x_i)$). 

Plugging these into @eq-foc-leaf,

$$
\begin{aligned}
w_j^* & = \frac{\sum_{i\in I_j}r_{i,b}}{\sum_{i\in I_j}1 + \lambda} \\
      & = \frac{\sum_{i\in I_j}r_{i,b}}{N_j + \lambda}
\end{aligned}
$$ {#eq-w-reg}

That is for a given leaf $j$, the optimal predicted value ($w_j^*$) is the sum of the residuals of all the observations in leaf $j$ divided by the number of observations in leaf $j$ plus $\lambda$. When $\lambda = 0$, the optimal predicted value ($w_j^*$) is simply the mean of the residuals.

The quality score for leaf $j$ is then, 

$$
Q_j = \frac{(\sum_{i\in I_j}r_{i,b})^2}{N_j + \lambda}
$$ {#eq-q-reg}



### Illustration of XGB for regression

In order to further our understanding of the entire XGB algorithm, let's take a lookt at a simple regression problem as an illustration. We consider a four-observation data as follows:

```{r}
(
data <-
  data.table(
    y = c(-3, 7, 8, 12),
    x = c(1, 4, 6, 8)
  )
)
```

```{r}
(
g_0 <-
  ggplot(data) +
  geom_point(aes(y = y, x = x))
)
```

First step ($b = 0$) is to make an initial prediction. This can be any number, but let's use the mean of `y` and set it as the predicted value for all the observations.

```{r}
(
f_0 <- mean(data$y) # f_0: the predicted value for all the observations
)
```

Let's set $\gamma$, $\lambda$, and $\eta$ to $10$, $1$, and $0.3$, respectively.

```{r}
gamma <- 10
lambda <- 1
eta <- 0.3
```

We have a single-leaf tree at the moment. And the quality score for this leaf is 

::: {.column-margin}
quality score for leaf $j$ is $\frac{(\sum_{i\in I_j}r_{i,b})^2}{N_j + \lambda}$
:::

```{r}
#=== get residuals ===#
data[, resid := y - f_0]

#=== get quality score ===#
(
q_0 <- (sum(data$resid))^2/(nrow(data) + 1)
)
```

Quality score of the leaf is `r q_0`. 

::: {.column-margin}
Since we are using the mean of $y$ as the prediction, of course, the sum of the residuals is zero, which then means that the quality score is zero.
:::

Now, we have three potential to split patterns: {`x`, 2}, {`x`, 5}, {`x`, 7}. 

::: {.column-margin}
{`x`, 2} means the leaf is split into two leaves: ${x | x <2}$ and ${x | x >= 2}$. Note that any number between $1$ and $4$ will result in the same split results.
:::

Let's consider them one by one. 

#### <span style="color:blue"> Split: {`x`, 2} </span>

Here are graphical representations of the split:

```{r}
g_0 +
  geom_vline(xintercept = 2, color = "red") +
  annotate("text", x = 1.25, y = 6, label = "leaf L", color = "red") +
  annotate("text", x = 5, y = 6, label = "leaf R", color = "red")
```

::: {.column-margin}
```{r}
#| code-fold: true

DiagrammeR::grViz(
"
digraph {
  graph [ranksep = 0.2]
  node [shape = box]
    T1R [label = 'L: -9']
    T1L [label = 'R: 1 , 2 , 6']
    T0 [label = '-9, 1 , 2 , 6']
  edge [minlen = 2]
    T0->T1L
    T0->T1R
  { rank = same; T1R; T1L}
}
"
)
```
:::


Let's split the data.

```{r}
#=== leaf L ===#
(
data_L_1 <- data[x < 2, ]
)

#=== leaf R ===#
(
data_R_1 <- data[x >= 2, ]
)
```

Using @eq-w-reg, 

::: {.column-margin}
$w_j^* = \frac{\sum_{i\in I_j}r_{i,b}}{N_j + \lambda}$
:::

```{r}
w_L <- (sum(data_L_1$resid))/(nrow(data_L_1) + lambda)
w_R <- (sum(data_R_1$resid))/(nrow(data_R_1) + lambda)
```

$$
\begin{aligned}
w_L^* & = -9 / (`r nrow(data_L_1)` + `r lambda`) = `r round(w_L, digits = 2)` \\
w_R^* & = 1 + 2 + 6 / (`r nrow(data_R_1)` + `r lambda`) = `r round(w_R, digits = 2)`
\end{aligned}
$$


Using @eq-q-reg, the quality scores for the leaves are

::: {.column-margin}
$Q_j = \frac{(\sum_{i\in I_j}r_{i,b})^2}{N_j + \lambda}$
:::

```{r}
q_L <- (sum(data_L_1$resid))^2/(nrow(data_L_1) + lambda)
q_R <- (sum(data_R_1$resid))^2/(nrow(data_R_1) + lambda)
```

::: {.column-margin}
```{r}
#| code-fold: true

DiagrammeR::grViz(
  paste0(
  "
  digraph {
    graph [ranksep = 0.2]
    node [shape = box]
      T1R [label = 'L: -9 \n Q score = ", round(q_L, digits = 2), "']
      T1L [label = 'R: 1 , 2 , 6 \n Q score = ", round(q_R, digits = 2), "']
      T0 [label = '-9, 1 , 2 , 6']
    edge [minlen = 2]
      T0->T1L
      T0->T1R
    { rank = same; T1R; T1L}
  }
  "
  )

)
```
:::


$$
\begin{aligned}
q_L^* & = (-9)^2 / (`r nrow(data_L_1)` + `r lambda`) = `r round(q_L, digits = 2)` \\
q_R^* & = (1 + 2 + 6)^2 / (`r nrow(data_R_1)` + `r lambda`) = `r round(q_R, digits = 2)`
\end{aligned}
$$

Notice that residuals are first summed and then squared in the denominator of the quality score (the higher, the better). This means that if the prediction is off in the same direction (meaning they are similar) among the observations within the leaf, then the quality score is higher. On the other hand, if the prediction is off in both directions (meaning they are not similar), then the residuals cancel each other out, resulting in a lower quality score. Since we would like to create leaves consisting of similar observations, a more successful split has a higher quality score. 

Finally, the gain of this split is 

::: {.column-margin}
$$
G(s, L, R) = \frac{1}{2} \huge[\normalsize Q_L + Q_R - Q_s \huge]\normalsize - \gamma
$$
where $s$ is the leaf before split, $L$ and $R$ are leaves after the split of leaf $s$.
:::

```{r}
gain_1 <- (q_L + q_R - q_0)/2 - gamma
```

$$
G_1 = \frac{`r round(q_L, digits = 2)` + `r round(q_R, digits = 2)` - `r q_0`}{2} - `r gamma` = `r gain_1`
$$


Now that we have gone through the process of finding update value ($w$), quality score ($q$), and gain ($G$) for a given split structure, let's write a function that returns the values of these measures by feeding the cutpoint before moving onto the next split candidate.

```{r}
get_info <- function(data, cutpoint, lambda, gamma)
{
  q_0 <- (sum(data$resid))^2/(nrow(data) + lambda)

  data_L <- data[x < cutpoint, ]
  data_R <- data[x >= cutpoint, ]

  w_L <- (sum(data_L$resid))/(nrow(data_L) + lambda)
  w_R <- (sum(data_R$resid))/(nrow(data_R) + lambda)

  q_L <- (sum(data_L$resid))^2/(nrow(data_L) + lambda)
  q_R <- (sum(data_R$resid))^2/(nrow(data_R) + lambda)

  gain <- (q_L + q_R - q_0)/2 - gamma

  return(list(
    w_L = w_L, 
    w_R = w_R, 
    q_L = q_L, 
    q_R = q_R, 
    gain = gain 
  ))
}
```

#### <span style="color:blue"> Split: {`x`, 5} </span>

```{r}
measures_2 <- get_info(data, 5, lambda, gamma)
```

```{r}
g_0 +
  geom_vline(xintercept = 5, color = "red") +
  annotate("text", x = 3, y = 6, label = "leaf L", color = "red") +
  annotate("text", x = 7, y = 6, label = "leaf R", color = "red")
```

::: {.column-margin}
```{r}
#| code-fold: true

DiagrammeR::grViz(
  paste0(
    "
    digraph {
      graph [ranksep = 0.2]
      node [shape = box]
        T1R [label = 'L: -9, 1 \n Q score = ", round(measures_2$q_L, digits = 2), "']
        T1L [label = 'R: 2 , 6 \n Q score = ", round(measures_2$q_R, digits = 2), "']
        T0 [label = '-9, 1 , 2 , 6']
      edge [minlen = 2]
        T0->T1L
        T0->T1R
      { rank = same; T1R; T1L}
    }
    "
  )
)
```
:::

$$
\begin{aligned}
q_L^* & = (-9)^2 / (2 + `r lambda`) = `r round(measures_2$q_L, digits = 2)` \\
q_R^* & = (1 + 2 + 6)^2 / (2 + `r lambda`) = `r round(measures_2$q_R, digits = 2)`
\end{aligned}
$$

$$
G_2 = \frac{`r round(measures_2$q_L, digits = 2)` + `r round(measures_2$q_R, digits = 2)` - `r q_0`}{2} - `r gamma` = `r measures_2$gain`
$$

#### <span style="color:blue"> Split: {`x`, 7} </span>

```{r}
measures_3 <- get_info(data, 7, lambda, gamma)
```

```{r}
g_0 +
  geom_vline(xintercept = 7, color = "red") +
  annotate("text", x = 4, y = 6, label = "leaf L", color = "red") +
  annotate("text", x = 8, y = 6, label = "leaf R", color = "red")
```

::: {.column-margin}
```{r}
#| code-fold: true

DiagrammeR::grViz(
  paste0(
    "
    digraph {
      graph [ranksep = 0.2]
      node [shape = box]
        T1R [label = 'L: -9, 1, 2 \n Q score = ", round(measures_3$q_L, digits = 2), "']
        T1L [label = 'R: 6 \n Q score = ", round(measures_3$q_R, digits = 2), "']
        T0 [label = '-9, 1 , 2 , 6']
      edge [minlen = 2]
        T0->T1L
        T0->T1R
      { rank = same; T1R; T1L}
    }
    "
  )
)
```
:::


$$
\begin{aligned}
q_L^* & = (-9)^2 / (1 + `r lambda`) = `r round(measures_3$q_L, digits = 2)` \\
q_R^* & = (1 + 2 + 6)^2 / (3 + `r lambda`) = `r round(measures_3$q_R, digits = 2)`
\end{aligned}
$$

$$
G_3 = \frac{`r round(measures_3$q_L, digits = 2)` + `r round(measures_3$q_R, digits = 2)` - `r q_0`}{2} - `r gamma` = `r measures_3$gain`
$$

Among all the splits we considered, the first case (Split: {`x`, 2}) has the highest score. This is easy to confirm visually and shows picking a split based on the gain measure indeed makes sense. 

Now we consider how to split leaf R (leaf L cannot be split further as it has only one observation). We have two split candidates: {`x`, 5} and {`x`, 7}. Let's get the gain measures using `get_info()`.

```{r}
#=== first split ===#
get_info(data_R_1, 5, lambda, gamma)$gain 

#=== second split ===#
get_info(data_R_1, 7, lambda, gamma)$gain
```

So, neither of the splits has a positive gain value. Therefore, we do not adopt either of the splits. For this iteration ($b=1$), this is the end of tree building. 

:::{.callout-note}
If the value of $\gamma$ is lower (say, 0), then we would have adopted the second split. 

```{r}
get_info(data_R_1, 5, lambda, 0)$gain # first split
get_info(data_R_1, 7, lambda, 0)$gain # second split
```

As you can see, a higher value of $\gamma$ leads to a more aggressive tree pruning. 
:::

So, the final tree for this iteration ($b = 1$) is

```{r}
#| code-fold: true
#| fig-height: 2
#| fig-width: 4

DiagrammeR::grViz(
  paste0(
  "
  digraph {
    graph [ranksep = 0.2]
    node [shape = box, width = 0.3, height = 0.15, fontsize = 3, fixedsize = TRUE, penwidth = 0.2]
      T1R [label = 'L: -9 \n w* = ", round(w_L, digits = 2), "']
      T1L [label = 'R: 1 , 2 , 6 \n w* = ", round(w_R, digits = 2), "']
      T0 [label = '-9, 1 , 2 , 6']
    edge [penwidth = 0.2, arrowsize = 0.3, len = 0.3]
      T0->T1L
      T0->T1R
    { rank = same; T1R; T1L}
  }
  "
  )

)
```

We now use $w^*$ from this tree to update our prediction according to @eq-update. 

::: {.column-margin}
$f_{i,b} = f_{i,b-1} + \eta \cdot w_j^*$
:::

```{r}
measures_1 <- get_info(data, 2, lambda, gamma)
```

Since the first observation is in $L$, 

$$
f_{i = 1,b = 1} = `r f_0` + `r eta` \times `r round(measures_1$w_L, digits = 2)` = `r round(f_0 + eta * measures_1$w_L, digits = 2)` 
$$

Since the second, third, and fourth observations are in $R$,

$$
\begin{aligned}
f_{i = 2,b = 1} = `r f_0` + `r eta` \times `r round(measures_1$w_R, digits = 2)` = `r round(f_0 + eta * measures_1$w_R, digits = 2)` \\
f_{i = 3,b = 1} = `r f_0` + `r eta` \times `r round(measures_1$w_R, digits = 2)`  = `r round(f_0 + eta * measures_1$w_R, digits = 2)`\\
f_{i = 4,b = 1} = `r f_0` + `r eta` \times `r round(measures_1$w_R, digits = 2)` = `r round(f_0 + eta * measures_1$w_R, digits = 2)`
\end{aligned}
$$

```{r}
data %>% 
  .[, f_0 := f_0] %>% 
  .[1, f_1 := f_0 + measures_1$w_L * eta] %>%
  .[2:4, f_1 := f_0 + measures_1$w_R * eta]
```

The prediction updates can be seen below. Though small, we made small improvements in our prediction.

```{r}
#| code-fold: true 

ggplot(data = data) +
  geom_point(aes(y = y, x = x, color = "observed")) +
  geom_point(aes(y = f_1, x = x, color = "after (f1)")) +
  geom_point(aes(y = f_0, x = x, color = "before (f0)")) +
  scale_color_manual(
    values = 
      c(
        "before (f0)" = "blue", 
        "after (f1)" = "red",
        "observed" = "black"
      ), 
    name = ""
  ) +
  geom_segment(
    aes(y = f_0, x = x, yend = f_1, xend = x), 
    color = "blue",
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  theme_bw()

```

Now, we move on to $b=2$. We first update residuals:

```{r}
data[, resid := y - f_1]

data
```

Just like at $b=1$, all the possible splits are {`x`, 2}, {`x`, 5}, {`x`, 7}. Let's find the gain for each split.

```{r}
lapply(
  c(2, 5, 7),
  function(x) get_info(data, x, lambda, gamma)$gain
)
```

So, the first split is again the best split. Should we split the right leaf, which has the observations except the first one?

```{r}
lapply(
  c(5, 7),
  function(x) get_info(data[2:3, ], x, lambda, gamma)$gain
)
```

All the splits have negative gains. So, we do not split this leaf just like at $b=1$. 

So, the final tree for this iteration ($b = 1$) is

```{r}
measures_b2 <- get_info(data, 2, lambda, gamma)

#| code-fold: true
#| fig-height: 2
#| fig-width: 4

DiagrammeR::grViz(
  paste0(
  "
  digraph {
    graph [ranksep = 0.2]
    node [shape = box, width = 0.4, height = 0.15, fontsize = 3, fixedsize = TRUE, penwidth = 0.2]
      T1R [label = 'L: -8.18 \n w* = ", round(measures_b2$w_L, digits = 2), "']
      T1L [label = 'R: 0.71 , 1.71 , 5.71 \n w* = ", round(measures_b2$w_R, digits = 2), "']
      T0 [label = '-8.18, 0.71 , 1.71 , 5.71']
    edge [penwidth = 0.2, arrowsize = 0.3, len = 0.3]
      T0->T1L
      T0->T1R
    { rank = same; T1R; T1L}
  }
  "
  )

)
```

Let's now update our predictions.

```{r}
data %>% 
  .[1, f_2 := f_1 + measures_b2$w_L * eta] %>%  
  .[2:4, f_2 := f_1 + measures_b2$w_R * eta] 
```

```{r}
#| code-fold: true 

ggplot(data = data) +
  geom_point(aes(y = y, x = x, color = "observed")) +
  geom_point(aes(y = f_2, x = x, color = "f2")) +
  geom_point(aes(y = f_1, x = x, color = "f1")) +
  geom_point(aes(y = f_0, x = x, color = "f0")) +
  scale_color_manual(
    values = 
      c(
        "f0" = "blue", 
        "f1" = "red",
        "f2" = "red",
        "observed" = "black"
      ), 
    name = ""
  ) +
  geom_segment(
    aes(y = f_0, x = x, yend = f_1, xend = x), 
    color = "blue",
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  geom_segment(
    aes(y = f_1, x = x, yend = f_2, xend = x), 
    color = "blue",
    arrow = arrow(length = unit(0.1, "cm"))
  ) +
  theme_bw()
```

Again, we made small improvements in our predictions. This process continues until user-specified stopping criteria is met.

:::{.callout-tip}
+ $\lambda$: 
  * A higher value of $\lambda$ leads to a lower value of prediction updates ($w^*$).
  * A higher value of $\lambda$ leads to a lower value of quality score ($Q$), thus leading to a lower value of gain ($G$), which then leads to more aggressive pruning for a given value of $\gamma$.
+ $\gamma$:
  * A higher value of $\gamma$ leads to more aggressive pruning.
+ $\eta$:
  * A higher value of $\eta$ leads to faster learning.

:::

### Implementation 


```{r}
library(xgboost)

mlb1_dm_X <- 
  xgb.DMatrix(
    data = as.matrix(mlb1_dt[, .(hruns, years, rbisyr, allstar, runsyr, hits, bavg)]),
    label = as.matrix(mlb1_dt[, lsalary])
  )

xgb.train(
  data = mlb1_dm_X, # independent variable
  nrounds = 100,
  eta = 1,
  objective = "reg:squarederror"

)

```




## Over-fitting




## Resources

+ [Gradient Boosting with Scikit-Learn, XGBoost, LightGBM, and CatBoost](https://machinelearningmastery.com/gradient-boosting-with-scikit-learn-xgboost-lightgbm-and-catboost/) by Jason Brownlee
+ [A Gentle Introduction to XGBoost for Applied Machine Learning](https://machinelearningmastery.com/gentle-introduction-xgboost-applied-machine-learning/)